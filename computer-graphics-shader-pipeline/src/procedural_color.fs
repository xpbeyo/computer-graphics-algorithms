// Set the pixel color to an interesting procedural color generated by mixing
// and filtering Perlin noise of different frequencies.
//
// Uniforms:
uniform mat4 view;
uniform mat4 proj;
uniform float animation_seconds;
uniform bool is_moon;
// Inputs:
in vec3 sphere_fs_in;
in vec3 normal_fs_in;
in vec4 pos_fs_in; 
in vec4 view_pos_fs_in; 
// Outputs:
out vec3 color;

// Reference: http://physbam.stanford.edu/cs448x/old/Procedural_Noise(2f)Perlin_Noise.html
float turbulence(vec3 pos, float pixel_size) {
  float x = 0.0;
  float scale = 1.0;
  while (scale > pixel_size) {
    pos /= scale;
    x += perlin_noise(pos) * scale;
    scale /= 2;
  }
  return x;
}
vec3 marble(vec3 pos) {
  vec3 rgb = vec3(0.0);
  float x = sin((pos.y + 3.0 * turbulence(pos, 0.8)) * M_PI);
  x = sqrt(x + 1) * 0.7071;
  rgb.y = 0;
  x = sqrt(x);
  rgb.x = 0;
  rgb.z = x;
  return rgb;
}
vec3 marble_gray(vec3 pos) {
  vec3 rgb = vec3(0.0);
  float x = sin((pos.y + 3.0 * turbulence(pos, 0.8)) * M_PI);
  x = sqrt(x + 1) * 0.7071;
  rgb.y = 128/255.0 * x;
  x = sqrt(x);
  rgb.x = 128/255.0 * x;
  rgb.z = 128/255.0 * x;
  return rgb;
}

// expects: blinn_phong, perlin_noise
void main()
{
  float angle = 2 * M_PI * (animation_seconds / 6.0);
  vec3 light_dir = normalize(vec3(cos(angle), 0.7, sin(angle)));
  vec3 view_dir = -normalize(view_pos_fs_in.xyz);
  

  // Set up the constants
  vec3 ka, kd, ks;
  float p;
  if (!is_moon) {
    ka = vec3(0.01);
    kd = marble(sphere_fs_in);
    ks = vec3(1);
    p = 1000;

  }
  else {
    ka = vec3(0.01);
    kd = marble_gray(sphere_fs_in);
    ks = vec3(0.5);
    p = 1000;
  }
  color = blinn_phong(ka, kd, ks, p, normalize(normal_fs_in), view_dir, light_dir);
}
